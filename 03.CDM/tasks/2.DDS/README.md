# Формирование исторической таблицы (слоя DDS)

Когда вы очистили данные, пришло время их аккуратно структурировать:
События будем хранить в формате SCD2 (Больше о формате можно почитать на популярных ресурсах, например: https://ru.wikipedia.org/wiki/Медленно_меняющееся_измерение).

Добавим более строгие определения:
1. В качестве ключей будем использовать: order_id + item_id;
2. В качестве временных меток: valid_from_dttm + valid_to_dttm;
3. В качестве "открытой" даты (для актуального состояния позиции заказа) будем использовать "2105-12-31 00:00:00".

Схема таблицы приложена ниже:

| \# | name            | type               |
|----|-----------------|--------------------|
| 1	 | order_id	       | Int64              |
| 2	 | item_id	       | Int64[optional]    |
| 3	 | valid_from_dttm | Datetime[optional] |
| 4  | valid_to_dttm   | Datetime[optional] |
| 5	 | cyr	           | String[optional]   |
| 6	 | item_count	   | Int64[optional]    |
| 7	 | item_price	   | Int64[optional]    |
| 8	 | order_status	   | String             |
| 9	 | sku	           | Int64[optional]    |
| 10 | user_id	       | Int64              |


Также схема таблицы есть в папке с задачей: //home/homework_task_dwh

>>> [!note] P.S.:
1. Не забывайте об удаленных позициях (Подумайте, какими значениями лучше заполнять поля для таких событий. Рекомендую использовать NULL для полей cyri, tem_count, item_price, sku);
2. В промышленной разработке схема более сложная, и мы будем рады, если вы погрузитесь в эту тему больше;
3. Таблица должна быть отсортирована по order_id, item_id, valid_from_dttm, valid_to_dttm.
4. Для запуска проверки, верните в функции ``get_table_path()`` путь до получившейся таблицы;
>>>
